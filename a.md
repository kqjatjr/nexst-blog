# 정렬 알고리즘

---

## 선택정렬(Selection Sort)

선택 정렬은 가장 간단한 정렬 알고리즘 중 하나로, 입력에 민감하지 않은 정렬이다. 또한 선택 정렬은 항상 일정한 시간복잡도를 가지는 정렬 알고리즘이기도 하다.

### 선택 정렬 알고리즘

1. 배열 `A[1..n]`에서 가장 큰 원소를 찾는다.
2. 가장 큰 원소와 끝잦리에 있는 `A[n]`과 자리를 바꾼다. -> 여기서 맨 뒷자리로 옮긴 원소는 자기 자리를 찾은 것이므로 이제 신경쓰지 않아도 된다.
3. 나머지 원소 `n-1`개에 대해서도 동일한 작업을 반복한다.

### 수행시간

선택 정렬의 수행시간은 모든 경우에 `O(n^2)`이다. 선택 정렬은 selectionSort에서 수를 비교하는 횟수가 전체 시간을 좌우하기 때문에 이를 기준으로 수행시간을 분석한다.

### 특징

- 장점 : 자료 이동 횟수가 미리 결정된다.
- 단점 : 안정성을 보장하지 못한다.(값이 동일한 원소가 있을 경우, 정렬되며 이들의 상대적 위치가 바뀔 수 있다.)

## 버블정렬 (Bubble Sort)

버블 정렬도 위에서 본 선택 정렬과 유사하게, 가장 큰 값을 오른쪽으로 옮기는 정렬 알고리즘이다.

### 버블 정렬 알고리즘

1. 정렬한 배열이 주어지면, 왼쪽부터 시작해 이웃한 쌍들을 비교한다.
2. 이웃한 쌍끼리 순서대로 정렬되어 있지 않으면 자리를 바꾼다.
3. 배열의 끝까지 `(n-1)`번 비교한 후, 맨 마지막에 있는 원소를 제외 한 후 나머지 원소들에 대해 계속 위의 과정을 반복한다.

### 수행 시간

버블 정렬에서 수행시간은 평균과 최악의 경우 `O(n^2)`이다. 버블 정렬은 수를 비교하는 횟수가 전체 시간을 좌우하기 때문에 이를 기준으로 수행시간을 분석한다.

하지만, 최선을 대는 `O(n)`의 수행시간을 가질 수 있다. 배열이 정렬되어 들어올때 이러한 최선의 수행시간을 가질 수 있다.

## 삽입정렬(Insertion Sort)

삽입 정렬은 이미 정렬되어 있는 i개 짜리 배열에 하나의 원소를 더하여 정렬된 i+1개짜리 배열을 만드는 과정을 반복하는 정렬알고리즘이다. 선택 정렬과 버블 정렬은 n개 짜리 배열에서 시작하여, 그 크기를 하나씩 줄이는 것에 비해, 삽입 정렬은 이와 반대로 한개짜리 배열에서 시작하여 그 크기를 하나씩 늘리는 정렬이다.

### 삽입 정렬 알고리즘

1. 배열이 주어지면, 배열의 두 번째 원소부터 시작하여 그 앞의 자료들과 비교하여, 삽입할 위치를 찾는다.

2. 원소를 삽입할 위치 뒤에 있는 원소들을 뒤로 옮긴다.

3. 그 다음 지정한 자리에 원소를 삽입한다. 모든 배열이 정렬될 때까지 이 과정을 반복한다.

### 수행시간

삽입정렬에서 수행시간은 최작일 경우에 `O(n^2)`이다. 삽입정렬은 수행시간이 `O(n^2)`인 비효율적인 정렬알고리즘이다. 하지만 배열이 거의 정렬된 상태에서 입력되는 경우에 가장 매력적인 알고리즘이다. 배열이 완전히 정렬된 상태로 입력되면 while문은 한번도 수행되지 안흔다. for문만 한번 순회하기 때문에 `O(n)`의 시간이 소요된다. 삽입 정렬은 배열이 이미 정렬된 상태라면 버블 정렬에서처럼 굳이 다른 코드를 추가하지 않아도 효율적으로 끝난다.

### 정리

- 평균과 최악의 경우 수행시간은 `O(n^2)`
- 최선의 수행시간은 `O(n)`

---

## 병합 정렬(Merge Sort)

병합 정렬은 분할 정복 방법을 사용하는 정렬 알고리즘이다. 입력을 반으로 나누어 전반부와 후반부를 각각 독립적으로 정렬한다. 그 다음 두 부분을 병합하여 정렬된 배열을 얻는다.

### 병합 정렬 알고리즘

1. 정렬할 배열이 주어지면, 이 배열을 반으로 나눈다.
2. 나눈 각각의 배열을 독립적으로 정렬한다.
3. 나눈 배열을 병합하여 정렬을 완료한다.

### 수행시간

최악의 경우에도 `O(nlogn)`이다.

## 퀵 정렬(Quick Sort)

퀵 정렬은 평균적으로 가장 높은 성능을 가져 가장 많이 쓰이는 정렬 알고리즘이다. 퀵 정렬은 비균등 분할 정복 방식을 사용한다.

### 퀵 정렬 알고리즘

1. 정렬할 배열이 주어지면, 맨 뒤의 원소를 기준원소(피벗)로 삼는다. (기준 원소는 반드시 맨 마지막일 필요는 없다.)

2. 기준 원소보다 작은 수는 기준의 왼쪽에 나머지는 기준의 오른쪽에 오도록 배치한다.

3. 기준원소 왼쪽과 오른쪽을 독립적으로 정렬한다.

### 수행시간

이상적인 경우는, 분할이 항상 반반씩 균등하게 될 때이다. 이때 수행시간은 `O(n)`이다.

최악의 경우는 계속해서 한쪽은 하나도 없고, 다른쪽에 다 몰리도록 분할되는 경우이다. 이때의 수행시간은 `O(n^2)`이다.

하지만 이렇게 계속 한쪽이 완전히 비거나 이러한 상황에 근접한 상태가 계속 반복될 경우는 매우 희박하다.

평균적인 경우, 퀵 정렬의 수행시간은 분할이 어떻게 균형있게 되냐에 달려있따 .따라서 평균 수행시간은 분할했을때 모든 경우를 평균내면 된다. 따라서 이때의 수행시간은 `O(nlogn)`이다.

## 힙 정렬 (Heap Sort)

힙정렬은 힙이라는 특수한 자료구조를 사용하는 정렬 알고리즘이다. 힙에는 최소 힙과 최대 힙이 있다. 여기서는 최소 힙을 기준으로 설명한다.

### 힙(Heap)

힙은 이진 트리로서 맨 아래 층을 제외하고는 완전히 채워져 있고, 맨 아래층은 왼쪽부터 꽉 채워져 있다. 힙 성질은 **"각 노드의 값은 자기 자식의 값보다 작다"**이다.

### 힙 만들기

힙은 링크나 포인터를 이용하여 만들 수 있찌만, 힙 정렬에서 사용하는 트리는 꽉찬 이진트리이기 때문에 더 간단하게 1차원 배열로 구현할 수 있다. `배열 A[k]의 자식은 A[2k], A[2k+1]`이다. 이를 이용해 힙을 만ㄷ르 수 있다.

### 힙을 만드는 방법

1. 주어진 배열 A에 수들이 아무렇게나 들어가있따.
2. 맨 뒤에서부터 따져 힙 성질에 위배되는지 확인하고, 힙 성질을 만족하도록 수정한다.

힙을 만드는 `heapify` 함수의 경우, 어떤 서브 트리도 높이가 `log2n`을 넘지 않으므로 **heapify을 한번 수행하는데 `O(logn)`이 소요된다**

### 정렬

힙을 완성한 후 정렬 작업을 진행한다. 루트 노드에 있는 원소를 제거하여 임시 배열에 저장한다. 루트 노드를 제거하면 트리의 크기가 하나 줄어든다. 이때 맨 끝에 있는 원소를 루트로 옮겨 새로운 루트로 삼는다. 이렇게 하면, 대부분의 경우 루트 노드와 자식 간에 힙성질이 개진다. 다시 `heapify()`를 이용해 힙성질을 만족하도록 다시 수정해야 한다.

### 수행시간

`O(nlogn)`

## 계수 정렬 (Counting Sort)

계수 정렬은 정렬하고자 하는 원소들의 값이 `O(n)`을 넘지 않는 경우에 사용할 수 있따. 예를들어 배열 `A[1..n]`의 원소들이 k를 넘지 않는 자연수인 경우를 들 수있다. 계수 정렬은 먼저 배0열의 원소를 훑어보고 1부터 k까지의 자연수가 각각 몇 번 나타나는지 센다. 이를 통해 `A[1..n]`의 각 원소가 몇 번째에 놓이면 되는지 계산할 수 있다.

### 수행시간

계수 정렬의 수행시간은 `O(n)`이다. 총 네게의 for문이 시간을 결정한다. 첫번째는 O(k), 두번째는 O(n), 세번째는 O(k), 네번째는 O(n)의 시간이 소요된다.

여기서 k가 O(n)을 초과하면 시간은 O(k)가 된다. k가 O(nlogn)을 초과하면 계수 정렬은 위의 고급 정렬들보다 매력이 없어진다.

그래서 일반적으로 계수 정렬은 k가 O(n)을 초과하지 않은 경우에 선형 시간에 정렬하기 위해 사용한다.

---

# 정렬 알고리즘 2차 정리

## Big O 표기법과 시간복잡도

알고리즘들의 성능을 판단하는 지표로 사용되는 시간복잡도와 공간복잡도가 있다. 시간복잡도는 알고리즘의 수행시간을 의미하는 지표이며, 공간복잡도는 알고리즘의 메모리 사용량을 의미한다.

보통 알고리즘에 대해서 공부하다보면 이 알고리즘의 시간복잡도는 `O(n)`입니다 이런식으로 이야기하는 것을 볼 수 있다. 이게바로 빅오 표기법이다.

> 이 함수는 n만큼의 데이터가 주어졌을대 "최악"의 경우 n만큼의 리소스를 소모한다.

이때 위에서 말한 리소스는 시간복잡도라면 시간이고 공간복잡도라면 메모리공간이 될 것이다. 하지만 보통 정렬알고리즘을 평가할때는 주로 시간복잡도에 집중하므로 여기서는 시간복잡도만 살펴보도록 하자.

먼저 시간복잡도에 대한 이해를 더 하기위해 이진탐색 알고리즘의 시간복잡도를 살펴보자. 이진탐색을 잘 모르는 사람은 술게임인 업다운을 생각해보자 다들 잘 알겠지만 업다운은 다른사람이 생각한 임의의 숫자를 맞춰야 하는 게임이다.

이때, 가장 질문을 최소화 할수 있는 방법은 무엇일까? 바로 첫 질문에 중간 값인 50을 부르는 것이다. 50을 부르고 상대방이 업 또는 다운을 하게되면 우리는 반대쪽에 있는 50개의 수는 버리고 나머지 50개만 다시 생각하면 되는 것이다.

이 게임에서 최악의 경우는 계속 업 &다운을 반복하다가 `o(logN)`번만에 끝나는 것이고 최선의 경우는 찾고자 하는 값을 첫 번째 추측으로 맞춰버린 상황 즉, 시간복잡도는 `O(1)`이다.

보는 바와 같이 최선의 결과와 최악의 결과 간 차이는 늘 있을 수 밖에 없기 때문에 보통 알고리즘을 평가할 때는 주로 최악의 경우를 생각한다. 그리고 이런 최악의 경우를 표현할 때 바로 빅오 표기법을 사용하는 것이다.

정렬 알고리즘은 컴퓨터 공학에서 중요시되는 문제 중 하나로, 어떤 데이터셋이 주어졌을대 이를 정해진 순서대로 나열하여 재배치하는 문제이다.

실제 개발을 하다보면 불규칙한 데이터들을 정렬 후 탐색해야 하는 경우가 꽤나 많이 발생하는데 이때상황에 맞는 알고리즘을 사용하여 효과적으로 문제를 해결할 수 있느냐 핵심이라고 볼 수 있다.

예를들어 1부터 10까지 적혀잇는 공이 불규칙하게 들어있는 주머니에서 공을 하나씩 꺼내어 작은 수부터 큰 수의 순서로 공을 나열한다고 생각해보자. 보통 이런 경우 사람도 어렵지 않게 슥슥 정렬해낸다. 하지만 컴퓨터가 다루는 데이터는 10000개일수도 1000000000개일수도 있다. 그리고 데이터베이스 같은 경우는 이론상 무한 개의 데이터를 다룰 수 있어야 한다.

이때 데이터가 정렬되어 있지 않다면 순차적으로 하나씩 데이터를 봐가면서 탐색해야 하지만, 데이터가 이미 정렬되어있따면 위에서 예시로 들었던 이진탐색과 같은 강력한 알고리즘을 사용할 수도 있따.

## 버블정렬

버블정렬은 거의 모든 상황에서 최악의 성능을 보여주지만, 이미 정렬된 자료에서는 1번만 순회하면 되기 때문에 최선의 성능을 보여주는 알고리즘이다. 이미 정렬되어 있는 데이터를 왜 정렬하냐는 의문이 들 수 있지만, 정렬 알고리즘 자체는 데이터가 정렬되어있는지 아닌지 모르고 작동하는 것이기 때문에 의미는 있다. 버블정렬은 다음과 같은 순서로 작동한다.

1. 0번재 원소와 1번째 원소를 비교 후 정렬
2. 1번재 원소와 2번째 원소를 비교 후 정렬
3. ...
4. n-1번재 원소와 n번째 원소를 비교 후 정렬

한번 순회할 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여서 버블 정렬이라고 부른다. 원리도 직관적이라서 구현하기 편하긴 하지만 꽤나 비효율적인 정렬 방식이다. 그래서 보통 처음 배울 때 한 번 짜보고 나면 실무에서 쓰는 경우도 드물다.

```javascript
function bubbleSort(input) {
  const len = input.length;
  let tmp = null;

  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len; j++) {
      if (input[j] > input[j + 1]) {
        //Swap
        tmp = input[j];
        input[j] = input[j + 1];
        input[j + 1] = tmp;
        tmp = null;
      }
    }
  }
  return input;
}
```

## 선택 정렬

선택정렬은 주어진 자료들 중에 현재 위치에 맞는 자료를 찾아 선택하여 위치를 교환하는 정렬알고리즘이다. 한번 순회를 돌게되면 알고리즘 상 전체 자료 중 가장 작은 값의 자료가 0번째 인덱스에 위치하게 되므로 그 다음 순회부터는 1번 인덱스부터 순회를 돌며 반복하면 된다. 선택 정렬은 다음과 같은 순서로 작동한다.

1. 0번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 0번째 인덱스와 스왑한다.
2. 1번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 1번째 인덱스와 스왑한다.
3. ...
4. n-1번 인덱스 ~ n번 인덱스 중 가장 작은 값을 찾아 n번째 인덱스와 스왑한다.

선택 정렬은 현재 자료가 정렬이 되어있건말건 무조건 전체 리스트를 순회해가며 검사하기 때문에 최선의 경우든 최악의 경우든 한결같이 `O(n^2)`의 시간복잡도를 가지고 있다.

```javascript
function selectionSort(input) {
  const len = input.length;
  let tmp = null;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len; j++) {
      if (input[i] < input[j]) {
        // Swap
        tmp = input[j];
        input[j] = input[i];
        input[i] = tmp;
        tmp = null;
      }
    }
  }
  return input;
}
```

## 삽입정렬

삽입정렬은 주어진 자료의 모든 요소를 앞에서부터 차례대로 정렬된 자료 부분과 자신의 위치를 찾아 삽입하는 정렬이다. 사실 인간이 직접 정렬하는 순서와 제일 흡사하다고 할 수 있는 정렬이다. 삽입정렬의 작동순서를 보자.

1. 0번 인덱스는 건너뛴다.
2. 0~1번 인덱스중 1번 인덱스 값이 들어가야할 위치를 찾아서 넣는다.
3. 0~2번 인덱스중 이번 인덱스 값이 들어가야할 위치를 찾아서 넣는다..

삽입 정렬은 최선의 경우 전체 자료를 한번만 순회하면 되기 때문에 `O(n)`의 시간복잡도를 가지지만 최악의 경우 `O(n^2)`의 시간복잡도를 가진다.

```javascript
function insertionSort(input){
  const len = input.length;
  for(let i = 1; i<len; i++){ // 두번째 인덱스 부터 시작
    const value = input[i]; // 인덱스 확인
    let j = i-1;
    for(; j> -1 &&* input[j] > value; j--){
      // 이미 정렬된 요소들을 뒤에서부터 살펴보다가
      // 살펴본 요소가 현재 요소보다 크다면
      // 살펴본 요소를 뒤로 한칸 보낸다.
      input[j + 1] = input[j]l;
    }
    input[j+1] = value;
  }
  return input
}
```

## 병합 정렬

병합 정렬은 일종의 분할 정복법 중 하나로 큰 문제를 작은 여러 개의 문제로 쪼개서 각각의 해결한 후 결과를 모아서 원래의 문제를 해결하는 방법이다. 병합이라는 이름 그대로 주어진 자료를 잘게 쪼갠 뒤 합치는 과정에서 정렬을 하는 알고리즘이다.

1. `[5, 0, 4, 1]`라는 자료를 받았다.
2. length가 1이 될때까지 자료 리스트를 반으로 쪼갠다.
3. `[5, 0]`, `[4, 1]`가 된다.
4. `[5]`, `[0]`, `[4]`, `[1]`가 된다.
5. 각 리스트의 길이가 1이 되었으므로 병합을 시작한다.
6. 왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합한다. `[5]`와 `[0]` 중 0이더 작으므로 새로운 리스트에 0을 먼저 병합한다.
7. `[0, 5]`생성
8. 왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합한다. `[4]`, `[1]`중 1이더 작으므로 새로운 리스트에 1을 먼저 병합한다.
9. `[1, 4]`생성
10. 이제 `[0, 5]`와 `[1, 4]`를 병합한다. 이 리스트들은 정렬되었기 때문에 작은 인덱스 일 수록 작은 값을 가진다는 것이 보장되어있다.
11. 왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합한다.
12. `[0]`생성 `[5]`와 `[1, 4]`가 남았다.
13. 왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합한다.
14. `[0, 1]`생성. `[5]`와 `[4]`가 남았다.
15. 마찬지로 과정을 반복하여 `[0, 1, 4, 5]`를만든다.

왼쪽의 0번 인덱스와 오른쪽의 0번 인덱스를 비교하여 적은 값을 먼저 병합을 보면 이 과정이 계속 반복되고 있는것을 볼 수 있따.

같은 방식으로 계속 반복하여 병합하고 있기 때문에 병합정렬은 보통 재귀함수로 구현한다. 또한 병합 정렬은 항상 `O(nlogn)`의 시간복잡도를 가지기 때문에 효율적이다. 그러나 원소의 개수만큼 리스트를 쪼개고 따로 저장하고 있어야 하기 때문에 `O(n)`의 공간복잡도를 가진다. 한마디로 메모리를 플아 수행속도를 얻는 경우라고 할 수 있다.

```javascript
function merge(left, right) {
  const result = [];
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
    while (left.length) {
      result.push(left.shift());
    }
    while (right.length) {
      result.push(right.shift());
    }
    return result;
  }
}

function mergeSort(input) {
  if (input.length < 2) {
    return input;
  }
  const middle = parseInt(input.length / 2);
  const left = inputlslice(0, middle);
  const right = input.slice(middle, input.length);
  return merge(mergeSort(left), mergeSort(right));
}
```

## 퀵정렬

퀵정렬도 병합정렬과 마찬가지로 분할정복을 통한 정렬방버이다. 벙합정렬과의 차이점은 병합정렬은 분할 단계에서는 아무것도 하지않고 병합하는 단계에서 정렬을 수행하지만, 퀵정렬은 분할당계에서 중요한 작업들을 수행하고 병합시에는 아무것도 하지 않는다는 점이다.

1. 입력된 자료 리스트에서 하나의 원소를 고른다 이 원소를 피벗이라고 한다.
2. 피벗을 기준으로 리스트를 둘로 분할한다.
3. 피벗을 기준으로 피벗보다 작은 원소들은 모두 피벗의 왼족으로 보낸다.
4. 피벗을 기준으로 피벗보다 큰 원소들은 모두 피벗의 오른쪽으로 보낸다.

```javascript
function quickSort(arr, left, right){
  if(left < right){
    //기준점을 찾고 기준점을 중심으로 더 작은수, 더 큰수 분류
    const i = position(arr, left, rihgt);
    //기준점 기준 좌측 정렬
    quickSort(arr, left, i - 1);
    //기준점 기준 우측 정렬
    quickSort(arr, i + 1, right).
  }

  return arr;
}

function position (arr, left, right){
  let i = left;
  let j = right;
  const pivot = arr[left];

  // 제자리 더 큰수 / 더 작은수 좌우 배치
  while (i < j){
    while (arr[j] > pivot){
      j--;
    }
    while (i < j && arr[i] <= pivot){
      i++;
    }

    tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  arr[left] = arr[j];
  arr[j] = pivot;

  return j;
}
```
